import json
import pandas as pd
import numpy as np
from typing import Optional, Dict, Any, List


def read_user():
    with open('data/users.json') as stream:
        users = json.load(stream)
    return users


def read_cars():
    with open('data/cars.json') as stream:
        cars = json.load(stream)
    return cars


def read_questions(position: int):
    with open('data/questions.json') as stream:
        questions = json.load(stream)

    for question in questions:
        if question['position'] == position:
            return question


def read_alternatives(question_id: int):
    alternatives_question = []
    with open('data/alternatives.json') as stream:
        alternatives = json.load(stream)

    for alternative in alternatives:
        if alternative['question_id'] == question_id:
            alternatives_question.append(alternative)

    return alternatives_question


def create_answer(payload):
    answers = []
    result = []

    with open('data/alternatives.json') as stream:
        alternatives = json.load(stream)

    for question in payload['answers']:
        for alternative in alternatives:
            if alternative['question_id'] == question['question_id']:
                answers.append(alternative['alternative'])
                break

    with open('data/cars.json') as stream:
        cars = json.load(stream)

    for car in cars:
        if answers[0] in car.values() and answers[1] in car.values() and answers[2] in car.values():
            result.append(car)

    return result


def read_result(user_id: int):
    user_result = []

    with open('data/results.json') as stream:
        results = json.load(stream)

    with open('data/users.json') as stream:
        users = json.load(stream)

    with open('data/cars.json') as stream:
        cars = json.load(stream)

    for result in results:
        if result['user_id'] == user_id:
            for user in users:
                if user['id'] == result['user_id']:
                    user_result.append({'user': user})
                    break

        for car_id in result['cars']:
            for car in cars:
                if car_id == car['id']:
                    user_result.append(car)

    return user_result


# Data Analysis Functions
def get_statistical_overview() -> Dict[str, Any]:
    """Get comprehensive statistical overview"""
    try:
        cars_df = pd.read_json('data/cars.json')
        users_df = pd.read_json('data/users.json')
        
        return {
            "datasets": {
                "cars": {
                    "total_records": len(cars_df),
                    "columns": list(cars_df.columns),
                    "data_types": cars_df.dtypes.astype(str).to_dict()
                },
                "users": {
                    "total_records": len(users_df),
                    "columns": list(users_df.columns),
                    "data_types": users_df.dtypes.astype(str).to_dict()
                }
            },
            "summary": "Statistical overview generated by Samarth's Data Analysis API"
        }
    except Exception as e:
        return {"error": str(e)}


def get_cars_statistics() -> Dict[str, Any]:
    """Get detailed statistics for car dataset"""
    try:
        cars_df = pd.read_json('data/cars.json')
        
        # Categorical statistics
        fuel_counts = cars_df['fuel'].value_counts().to_dict()
        price_counts = cars_df['price'].value_counts().to_dict()
        category_counts = cars_df['category'].value_counts().to_dict()
        
        return {
            "total_cars": len(cars_df),
            "fuel_distribution": fuel_counts,
            "price_distribution": price_counts,
            "category_distribution": category_counts,
            "unique_fuels": cars_df['fuel'].nunique(),
            "unique_categories": cars_df['category'].nunique(),
            "unique_prices": cars_df['price'].nunique()
        }
    except Exception as e:
        return {"error": str(e)}


def get_correlation_analysis() -> Dict[str, Any]:
    """Perform correlation analysis"""
    try:
        cars_df = pd.read_json('data/cars.json')
        
        # Create numerical mappings for correlation
        fuel_map = {'electric': 1, 'fossil': 2, 'bio': 3}
        price_map = {'low': 1, 'average': 2, 'high': 3}
        category_map = {'compact': 1, 'utilitary': 2, 'sporting': 3, 'suv': 4}
        
        cars_df['fuel_numeric'] = cars_df['fuel'].map(fuel_map)
        cars_df['price_numeric'] = cars_df['price'].map(price_map)
        cars_df['category_numeric'] = cars_df['category'].map(category_map)
        
        numeric_df = cars_df[['fuel_numeric', 'price_numeric', 'category_numeric']]
        correlation_matrix = numeric_df.corr().to_dict()
        
        return {
            "correlation_matrix": correlation_matrix,
            "insights": {
                "strongest_correlation": "Analyze the correlation matrix for relationships",
                "note": "Correlations are based on encoded categorical variables"
            }
        }
    except Exception as e:
        return {"error": str(e)}


def get_distribution_analysis(field: str) -> Dict[str, Any]:
    """Get distribution analysis for a specific field"""
    try:
        cars_df = pd.read_json('data/cars.json')
        
        if field not in cars_df.columns:
            raise ValueError(f"Field '{field}' not found in dataset")
        
        value_counts = cars_df[field].value_counts().to_dict()
        percentages = (cars_df[field].value_counts(normalize=True) * 100).round(2).to_dict()
        
        return {
            "field": field,
            "distribution": value_counts,
            "percentages": percentages,
            "total_unique_values": cars_df[field].nunique(),
            "most_common": cars_df[field].mode().iloc[0] if len(cars_df[field].mode()) > 0 else None
        }
    except Exception as e:
        raise ValueError(str(e))


def get_trend_analysis() -> Dict[str, Any]:
    """Analyze trends across datasets"""
    try:
        cars_df = pd.read_json('data/cars.json')
        users_df = pd.read_json('data/users.json')
        results_df = pd.read_json('data/results.json')
        
        # Analyze car preferences
        fuel_trends = cars_df['fuel'].value_counts().to_dict()
        price_trends = cars_df['price'].value_counts().to_dict()
        
        return {
            "car_trends": {
                "fuel_preferences": fuel_trends,
                "price_preferences": price_trends
            },
            "user_activity": {
                "total_users": len(users_df),
                "total_results": len(results_df)
            },
            "insights": "Trend analysis shows market preferences and user behavior patterns"
        }
    except Exception as e:
        return {"error": str(e)}


def filter_cars(fuel: Optional[str] = None, price: Optional[str] = None, category: Optional[str] = None) -> List[Dict]:
    """Filter cars by criteria"""
    with open('data/cars.json') as stream:
        cars = json.load(stream)
    
    filtered_cars = cars
    
    if fuel:
        filtered_cars = [car for car in filtered_cars if car.get('fuel') == fuel]
    
    if price:
        filtered_cars = [car for car in filtered_cars if car.get('price') == price]
    
    if category:
        filtered_cars = [car for car in filtered_cars if car.get('category') == category]
    
    return filtered_cars


def get_data_summary() -> Dict[str, Any]:
    """Get summary statistics for all datasets"""
    try:
        cars_df = pd.read_json('data/cars.json')
        users_df = pd.read_json('data/users.json')
        
        return {
            "cars_summary": {
                "count": len(cars_df),
                "columns": list(cars_df.columns),
                "fuel_types": cars_df['fuel'].unique().tolist(),
                "price_ranges": cars_df['price'].unique().tolist(),
                "categories": cars_df['category'].unique().tolist()
            },
            "users_summary": {
                "count": len(users_df),
                "columns": list(users_df.columns)
            }
        }
    except Exception as e:
        return {"error": str(e)}
